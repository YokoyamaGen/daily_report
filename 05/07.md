# 取り組んだ課題一覧
- タイピング
- 最強WEB問題集 50問
- もう怖くないGit！チーム開発で必要なGitを完全マスター
- Gitによるバージョン管理
- GitHub & Pull Request
- Learn Git Branching途中

# わかったこと

- Slackware系
  - openSUSE
    - `zypperコマンド`は`apt`や`yum`コマンドのようなパッケージ管理コマンド

- `SUID`とは「Set User ID」の略で、誰がそのファイルを実行しても、セットされたユーザで実行されるという状態(https://eng-entrance.com/linux-permission-suid)
- `SGID`とは「Set Group ID」の略であり、Linuxのグループに関しての特殊なパーミッション。「SUID」のグループ版となっている。(https://eng-entrance.com/linux-permission-sgid)


Git(Udemy)
  - `ブランチ`はコミットファイルを指したポインタ。ブランチにはコミットIDを記録したポインタ。ブランチのおかげで、複数人で複数機能を並行して開発できるようになる。分岐して作業できるおかげで他の人の作業の影響をうけない。
  - `HEAD`は今、自分が作業しているブランチを指しているポインタ。HEADは現在作業中のブランチの名前が入っているポインタ。
  - `ブランチ`および`HEAD`の情報はリポジトリ(.git)に格納されている。

  - マージには3種類ある
    - Fast Forward(早送りになるマージ)は、ブランチを枝分かれしてなかったときはブランチのポインタを前にすすめるだけ。masterブランチからhotfixブランチを作成した際に、masterブランチに変更がかからずに、hotfixブランチにしか変更がされていない状態で、masterブランチにhotfixブランチをマージした時。
    - Auto Merge(基本的なブランチ)は、枝分かれして開発していた場合、マージコミットという新しいコミットを作る。masterブランチからからhotfixブランチを作成した際に、両方のブランチで新しいコミットを作成した状態で、masterブランチにhotfixブランチをマージしたら、masterブランチに新しいコミットファイルが作成される。新しく作成されたコミットファイルには親コミットの情報が2つになる。1つ前のmasterとhotfixのコミット情報が親となる。`git add`が不要なのは、新たに圧縮ファイルの作成が不要なため。
    - コンフリクトは複数ブランチで同じファイルの同じ箇所を編集して、マージした際に発生する。`git merge`でコンフリクトを解消した後に`git add` + `git commit`をしなければいけないのは新しい圧縮ファイル、コミットファイル、インデックスファイルを作成し直す必要があるため。

  - コンフリクトが起きないようにするための方法
    - 複数人で同じファイルを編集しない
    - pullやmergeをする前に変更中の状態をなくしておく。(commitやstashしておく)

  - `git branch -m ブランチ名`で名前の変更。`-m`はmoveのm
  - `git branch -d ブランチ名`でmasterにマージされていない変更が残っている場合は削除できない。強制的に削除したい場合は`git branch -D`

  - リベース
    - マージと違い新しいコミットを作成するわけではなく、親コミットを別の親コミットに変更している。つまり、ベースを変えているため、リベースという。
    - 絶対にNGなこと。すでにgit pushしたコミットに対してリベースすること。masterブランチからきったfeatureブランチを新しくコミットした後に、pushする。そして、masterブランチで新しくコミットした後に、featureブランチをリベースると、Githubとローカルで差異ができてしまい、pushできなくなる。 **その際には`git push -f`もしてはいけない** 履歴が壊れてしまうため。
    - プッシュしてしまった場合は、リベースは使わずにマージで対応する。
    - マージとリベースを比較すると、履歴はリベースのほうがきれいになるが、コンフリクトの解消はマージの方が楽。リベースはコミットごとにコンフリクトを解消しなければいけない。マージは一度だけで済む。そのため、コンフリクトが発生しそうな場合はマージを使用する。

  - プルにはリベース型とマージ型がある
    - マージ型はプルするたびに履歴に残ってしまうが、リベース型だと履歴に残らない。
    - `git config --global pull.rebase true`で常にgit pullをリベース型にできる。
    - `git pull --rebase`でもリベース型でプルできる。

  - ステージの退避した作業を復活させる
    - `git stash apply --index`
  - 退避した作業を削除する。
    - `git stash drop`
    - `git stash clear`で全作業を削除する。

  - コミットの履歴を書き換える方法。 **git pushする前に有効**
    - 直前のコミットをやり直す。`git commit --amend`
    - 複数のコミットをやり直す。`git rebase -i コミットID`、`git rebase -i HEAD~3`
    - `HEAD~1`は直前の親コミット、`HEAD~２`は2番目の親コミット
    - `git rebase -i HEAD~3`で履歴を並べ替えたり、消したりもできる。
    - `git rebase -i HEAD~3`で`pick`を`squash`に変更すると履歴を1つにまとめられる。
    - `git rebase -i HEAD~3`で`pick`を`edit`にすることで、1つの履歴をわけることもできる。
    - `git reset`でステージングにしていない状態に戻す。


Git(Youtube)
  - `git add -p ファイル名`でファイルの中で複数箇所を修正していたら、addする箇所を選択できる。コミットの粒度を指定できる。

  - `git diff`でワークツリーとステージの差分、`git diff　--cached`でステージとリポジトリの差分を出力する。

  - Detached HEADHEADがブランチから外れて特定のコミットを指した状態。`git checkout コミットID`

  - gitは3wayマージを採用している。変更前と変更A、変更Bの3つのファイルをみて、マージ結果を表示する。

  - `git cherry-pick`で任意のコミットを取ってくる。

  - `git reflog`でブランチが過去にどのコミットを際していたかをみる。

  - `git reset`
    - `--soft`はHEADを指定したコミットをリセット。インデックスとワークツリーは無変化
    - `--mixed`はインデックスをリセット。`git add`の作業が無効化される。git resetのデフォルトの動作
    - `--hard`はインデックスとワークツリーをリセット。コミットしていない変更が消える。

  - コミットの粒度が細かいと履歴を並び替えたり、cherry-pickするのにも便利。粒度が大きいと不要な変更も混ざっている。
  - 一言でコミットを説明できるようになるレベルのコミット粒度。
  - 完了形（〜を修正しました）ではなく、現在形（〜の修正です）でメッセージを書く。

  - フォーク
    - 本流から派生する機能
    - フォークする理由は、本流をベースに開発したい。開発方針の相違により分家するなど。
    - gitのcloneに似ている。違いとしては、フォーク先からフォーク元へのPRが簡単に作れる。

  - `git revert HEAD`で新しいコミットを作ることで、変更を元に戻す。git push済みのコミットを元に戻したい時に使用する。
  - `HEAD^`で現在指定しているブランチよりも1番目の親のコミットをのことを意味している。2番目の親を指定する場合は`HEAD^^`
  - `HEAD~1`と`HEAD^`は同じ意味。`HEAD~`は2番目以降の親を指定する際に便利。

# 次やること
- タイピング
- Linucの問題集(Lv1-101)
- Learn Git Branching
- 課題提出用のリポジトリを作成

# 感じたこと
- Auto Mergeの場合はコミットメッセージを入力する画面がでるのに、Fast Forwardの際にはコミットメッセージを入力する画面がでないのはなぜだろうと思っておりましたが、Auto Mergeは新しいコミットファイルを作成されるからなのかと納得しました。
- 一つ一つのコマンドの裏側の動きを理解したことで、なぜgit mergeの後にgit addやgit commitコマンドを入力しなければ行けない時と不要な時がわかった。
- git rebaseはgit mergeするよりも履歴がきれいにできるんだな、ぐらいのイメージでした。内部動作を理解することによって、コマンドの理解を深めることができました。

# 学習時間
Today: 7 h 00 m

Total: 87 h 10 m
